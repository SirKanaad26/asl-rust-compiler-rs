# TODO: ASL-to-Rust Compiler

## Next Up: Types

### Parser Rule
Use `definitions` rule from grammar (line 48):
definitions : definition* EOF ;

### Types to Implement

1. **Builtin types** - `__builtin type id;`
2. **Abstract types** - `type id;`
3. **Type aliases** - `type id = typeSpec;`
4. **Structs** - `type QualId is (field1: Type1, field2: Type2)`
5. **Enums** - `enumeration id { A, B, C };`

### Expected Output Examples

```
type MyInt = integer;

type MyInt = i64;

enumeration Color { RED, GREEN, BLUE };

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Color { RED, GREEN, BLUE }

type Point is (x: integer, y: integer)

#[derive(Debug, Clone)]
pub struct Point {
    pub x: i64,
    pub y: i64,
}
```

### Files to Create/Modify
- src/codegen/types.rs - new file
- src/codegen/mod.rs - add pub mod types;
- src/main.rs - add parser.definitions() support

### Steps
- Create test .asl files for each type
- Find parser traits: grep -n "DefinitionContextAttrs\|DefTypeEnum\|DefTypeStruct" src/parser/aslparser.rs
- Implement codegen for each type variant
- Test each type

### Later: Functions
```
integer Add(integer a, integer b)
    return a + b;

pub fn Add(a: i64, b: i64) -> i64 {
    a + b
}
```

## Later: Statements
- `if/elsif/else`
- `for/while` loops
- assignments
- `return`

## Later: Expressions
- binary ops (+, -, *, /, etc.)
- comparisons
- function calls